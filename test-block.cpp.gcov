        -:    0:Source:test/test-block.cpp
        -:    0:Programs:5
        -:    1:#include "catch.hpp"
        -:    2:#include "block.hpp"
        -:    3:#include "data.hpp"
        -:    4:#include "keys.hpp"
        -:    5:
        -:    6:#define DATA_LIMIT	10
        -:    7:
        7:    8:TEST_CASE( "block tests", "[block]" ){
       12:    9:	std::shared_ptr<Block> block(new Block());
       12:   10:	std::shared_ptr<PrivateKey> key(PrivateKey::load_file("test/data/test.private"));
       12:   11:	std::vector<std::string> signatures;
        -:   12:
       66:   13:	for(unsigned int i = 0; i < DATA_LIMIT; ++i){
      120:   14:		std::shared_ptr<Data> d1(new Data(Address("SIG_REF","BLOCK_REF",DataType::Signature)));
      120:   15:		std::shared_ptr<Data> d2(new Data(Address("SIG_REF","",DataType::Publication)));
       60:   16:		key->sign(d1);
       60:   17:		key->sign(d2);
        -:   18:
       60:   19:		signatures.push_back(d1->get_signature());
       60:   20:		signatures.push_back(d2->get_signature());
        -:   21:
       60:   22:		block->add_data(d1);
       60:   23:		block->add_data(d2);
        -:   24:	}
        -:   25:
       12:   26:	SECTION( "block removes data objects" ){
        -:   27:		// Remove each Data object by the save hash	
       21:   28:		for( std::string s : signatures ){
       20:   29:			block->remove_data( s );		
        -:   30:		}
        -:   31:
        -:   32:		// Check the block is empty
        1:   33:		REQUIRE(block->size() == 0);
        -:   34:	}
       12:   35:	SECTION( "block adds data objects" ){
        -:   36:		
        -:   37:		// Check the expected size after initialization
        1:   38:		unsigned int expected = (2*DATA_LIMIT);
        1:   39:		REQUIRE(block->size()==expected);
        -:   40:
        -:   41:		// Create a new Data object and sign it
        2:   42:		std::shared_ptr<Data> d(new Data(Address("SIG_REF","",DataType::Publication)));
        1:   43:		key->sign(d);
        -:   44:
        -:   45:		// Add it to the block and make sure the size changes
        1:   46:		block->add_data(d);
        1:   47:		REQUIRE(block->size()==expected+1);
        -:   48:	}
       12:   49:	SECTION( "block doesn't add invalid data" ){
        -:   50:		// Invalid because it doesn't have a data reference
        2:   51:		std::shared_ptr<Data> d0(new Data(Address("","",DataType::Publication)));
        -:   52:
        -:   53:		// Invalid because it isn't signed
        2:   54:		std::shared_ptr<Data> d1(new Data(Address("SIG_REF","",DataType::Publication)));
        -:   55:
        -:   56:		// Invalid because it is a signature with no block reference
        2:   57:		std::shared_ptr<Data> d2(new Data(Address("SIG_REF","",DataType::Signature)));
        -:   58:
        1:   59:		key->sign(d0);
        1:   60:		key->sign(d2);
        -:   61:
        1:   62:		REQUIRE(block->size() == (2*DATA_LIMIT));
        -:   63:
        1:   64:		REQUIRE_FALSE(block->add_data(d0));
        1:   65:		REQUIRE_FALSE(block->add_data(d1));
        1:   66:		REQUIRE_FALSE(block->add_data(d2));
        -:   67:		
        -:   68:	}
       12:   69:	SECTION( "block generates a hash" ){
        2:   70:		std::string hash = block->hash();
        1:   71:		REQUIRE(!hash.empty());
        -:   72:	}
       12:   73:	SECTION( "block changes hashing variables" ){
        2:   74:		std::string hash1 = block->hash();
        1:   75:		block->change_hash();
        2:   76:		std::string hash2 = block->hash();
        -:   77:	
        1:   78:		REQUIRE(hash1 != hash2);
        -:   79:	}
       12:   80:	SECTION( "block gets and sets previous hash" ){
        1:   81:		block->set_previous("TEST");
        1:   82:		REQUIRE(block->get_previous() == "TEST");
        -:   83:	}
        9:   84:}
