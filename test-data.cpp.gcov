        -:    0:Source:test/test-data.cpp
        -:    0:Programs:5
        -:    1:#include "catch.hpp"
        -:    2:#include "data.hpp"
        -:    3:#include "keys.hpp"
        -:    4:
        -:    5:#include <cryptopp/osrng.h>
        -:    6:#include <cryptopp/rsa.h>
        -:    7:#include <sstream>
        -:    8:#include <fstream>
        -:    9:
        9:   10:TEST_CASE( "data object tests", "[data]" ){
       16:   11:	Address address("DATA_REF","BLOCK_REF",DataType::Signature);
       16:   12:	std::shared_ptr<Data> data(new Data(address));
       16:   13:	std::shared_ptr<PrivateKey> key(PrivateKey::load_file("test/data/test.private"));
        -:   14:
       16:   15:	std::ifstream f("test/data/test.public");
        8:   16:	if(f.is_open()){
       16:   17:		std::stringstream contents;
        8:   18:		contents << f.rdbuf();
       16:   19:		std::string pub_key = contents.str();
        -:   20:
        8:   21:		data->set_public_key(pub_key);
        -:   22:	}
        -:   23:
        8:   24:	key->sign(data);
        -:   25:
       16:   26:	SECTION( "data object can set/get address" ) {
        2:   27:		std::shared_ptr<Data> d(new Data());
        1:   28:		d->set_address(address);
        -:   29:
        2:   30:		Address a = d->get_address();
        -:   31:
        1:   32:		REQUIRE(std::get<0>(a) == std::get<0>(address));
        1:   33:		REQUIRE(std::get<1>(a) == std::get<1>(address));
        1:   34:		REQUIRE(std::get<2>(a) == std::get<2>(address));
        -:   35:	}
       16:   36:	SECTION( "data object can set/get public key" ){
        2:   37:		std::ifstream f("test/data/test.public");
        1:   38:		REQUIRE(f.is_open());
        -:   39:
        2:   40:		std::stringstream contents;
        1:   41:		contents << f.rdbuf();
        2:   42:		std::string pub_key = contents.str();
        -:   43:
        1:   44:		data->set_public_key(pub_key);
        1:   45:		REQUIRE(data->get_public_key() == pub_key);
        -:   46:	}
       16:   47:	SECTION( "data object can set/get a signature" ){
        2:   48:		std::string s = "TEST";
        1:   49:		data->set_signature(s);
        1:   50:		REQUIRE(data->get_signature() == s);
        -:   51:	}
       16:   52:	SECTION( "data object can set/get a data reference" ){
        2:   53:		std::string s = "TEST";
        1:   54:		data->set_data_ref(s);
        1:   55:		REQUIRE(data->get_data_ref() == s);
        -:   56:	}
       16:   57:	SECTION( "data object can set/get a block reference" ){
        2:   58:		std::string s = "TEST";
        1:   59:		data->set_block_ref(s);
        1:   60:		REQUIRE(data->get_block_ref() == s);
        -:   61:	}
       16:   62:	SECTION( "data object can set/get a data type" ){
        1:   63:		data->set_data_type(DataType::Publication);
        1:   64:		REQUIRE(data->get_data_type() == DataType::Publication);
        -:   65:	}
       16:   66:	SECTION( "data object can return all data as a string" ){
        2:   67:		std::string full = data->to_string(true);
        2:   68:		std::string part = data->to_string();
        -:   69:
        2:   70:		Address a = data->get_address();
        -:   71:
        2:   72:		std::string manual_full;
        2:   73:		std::string manual_part;
        -:   74:
        1:   75:		manual_part.append(std::get<0>(a));
        1:   76:		manual_part.append(std::get<1>(a));
        1:   77:		manual_part.append(std::to_string(std::get<2>(a)));
        1:   78:		manual_part.append(data->get_public_key());
        -:   79:
        1:   80:		manual_full.append(manual_part);
        1:   81:		manual_full.append(data->get_signature());
        -:   82:
        1:   83:		REQUIRE(full == manual_full);
        1:   84:		REQUIRE(part == manual_part);
        -:   85:	}
       16:   86:	SECTION( "data object that should be valid is verified" ){
        1:   87:		REQUIRE(data->verify());
        -:   88:	}
       11:   89:}
